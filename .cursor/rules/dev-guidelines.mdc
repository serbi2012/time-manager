---
description: 개발 철학, 설계 원칙, 코딩 규칙 등 프로젝트 개발 가이드라인
globs:
alwaysApply: true
---

# 개발 가이드라인 (Development Guidelines)

이 문서는 프로젝트의 **핵심 개발 철학**, **설계 원칙**, **코딩 규칙**을 정의합니다.
모든 개발은 이 가이드라인에 입각하여 진행되어야 하며, 예외는 없습니다.

---

## 핵심 철칙 (Core Principles)

> ⚠️ **절대 위반 금지**: 아래 철칙은 어떤 상황에서도 타협하지 않습니다.

### 1. 테스트 용이성 (Testability First)

모든 코드는 **테스트 가능**해야 합니다.

```
❌ 금지: 테스트할 수 없는 코드
✅ 필수: 유닛 테스트로 모든 기능을 검증할 수 있는 구조
```

**규칙:**

-   모든 비즈니스 로직은 **순수 함수**로 분리
-   순수 함수는 `lib/` 폴더에 위치
-   부수 효과(Side Effect)는 **훅** 또는 **스토어**에서만 처리
-   외부 의존성(Firebase, localStorage)은 **주입 가능**하게 설계
-   새 기능 추가 시 **테스트 케이스 작성 가능 여부**를 먼저 검토

**체크리스트:**

-   [ ] 이 함수를 목(mock) 없이 테스트할 수 있는가?
-   [ ] 입력과 출력이 명확한가?
-   [ ] 부수 효과가 분리되어 있는가?

---

### 2. 관심사 분리 (Separation of Concerns)

파일이 **300줄을 초과**하면 분리를 검토합니다.
**500줄을 초과**하면 반드시 분리합니다.

```
❌ 금지: 하나의 파일에 여러 책임
✅ 필수: 단일 책임 원칙 (SRP) 준수
```

**규칙:**

-   **한 파일 = 한 책임**
-   **한 컴포넌트 = 한 파일**: 하나의 React 컴포넌트(함수/클래스)는 반드시 하나의 파일에만 정의합니다. 같은 파일 안에 `function EmptyChart() { ... }`, `function ChartContent() { ... }`처럼 여러 컴포넌트를 두지 않고, 각각 `EmptyChart.tsx`, `ChartContent.tsx`로 분리합니다.
-   컴포넌트는 **UI 렌더링**만 담당
-   로직은 **훅** 또는 **lib 함수**로 분리
-   상태 관리는 **스토어**에서 처리
-   스타일이 복잡하면 **별도 CSS/styled 파일**로 분리

**인라인 JSX/콘텐츠 분화 (필수):**

-   **Popover `content`**, **Tooltip `title`**, **Modal 본문** 등 **50줄 이상의 JSX 블록**은 **반드시** 별도 컴포넌트로 분리합니다.
-   한 파일 안에 `content={<div>...</div>}` 형태로 긴 JSX를 두지 않습니다. `content={<SessionContextMenu ... />}` 처럼 **이름 있는 컴포넌트**로 추출합니다.
-   분리 기준: **역할 단위** (예: 컨텍스트 메뉴, 툴팁 내용, 바 셀, 행 라벨 등).

```
❌ 금지: 한 파일에 Popover content 100줄 인라인
content={<div style={{...}}><strong>...</strong>...</div>}

✅ 필수: 별도 컴포넌트로 분리
content={<SessionContextMenu work_name={...} on_edit={...} />}
```

**JSX 작성 위치 엄격 제한 (CRITICAL):**

> ⚠️ **절대 위반 금지**: JSX/DOM 태그는 **컴포넌트의 return 문에서만** 작성합니다.

컴포넌트 **return 문 외부** (로직 영역)에서 JSX를 작성하는 모든 경우는 **줄 수와 무관**하게 **즉시 컴포넌트로 분리**합니다.

**금지 영역 (JSX 작성 불가):**

-   `useMemo()` 내부
-   `useCallback()` 내부
-   옵션 배열 생성 시 (`options`, `columns` 등)
-   조건문 내부 (`if`, `switch`)
-   배열 메서드 내부 (`.map()`, `.filter()` 등의 콜백)
-   변수 할당문

```typescript
// ❌ 절대 금지: useMemo 안에 JSX (1줄이어도 금지)
const options = useMemo(() => {
    return data.map(item => ({
        label: <span>{item.name}</span> // ← 1줄이어도 금지!
    }));
}, []);

// ❌ 절대 금지: useMemo 안에 div (줄 수 무관)
const project_code_options = useMemo(() => {
    return raw_options.map(opt => ({
        label: (
            <div style={{ display: "flex" }}>  // ← 금지!
                <span>{opt.label}</span>
                <CloseOutlined onClick={...} />
            </div>
        )
    }));
}, []);

// ❌ 절대 금지: optionRender/dropdownRender 내 inline JSX
<Select
    optionRender={(option) => (
        <div style={{...}}>  // ← 금지!
            <span>{option.label}</span>
        </div>
    )}
/>

// ✅ 필수: 별도 컴포넌트로 분리
interface OptionLabelProps {
    label: string;
    onClose: () => void;
}

function OptionLabel({ label, onClose }: OptionLabelProps) {
    return (
        <div style={OPTION_LABEL_CONTAINER_STYLE}>
            <span>{label}</span>
            <CloseOutlined onClick={onClose} style={CLOSE_ICON_STYLE} />
        </div>
    );
}

const project_code_options = useMemo(() => {
    return raw_options.map(opt => ({
        label: <OptionLabel label={opt.label} onClose={() => hideOption(opt.value)} />
    }));
}, []);

// ✅ 필수: optionRender에 컴포넌트 사용
<Select
    optionRender={(option) => (
        <SelectOptionLabel label={option.label} onClose={handleClose} />
    )}
/>
```

**DOM 코드 길이 제한 (CRITICAL):**

컴포넌트의 **return 문 내 DOM 코드**:

-   **50줄 초과** → 분리 검토 권장
-   **100줄 초과** → 반드시 분리
-   **200줄 초과** → 즉시 분리 (절대 위반 금지)

```typescript
// ❌ 금지: return 문 내 DOM 200줄
function MyModal() {
    // ... 로직 100줄
    return (
        <Modal>
            {/* 300줄의 DOM 코드 */}  // ← 금지!
        </Modal>
    );
}

// ✅ 필수: 하위 컴포넌트로 분리
function MyModal() {
    return (
        <Modal>
            <ModalHeader {...} />
            <ModalBody {...} />
            <ModalFooter {...} />
        </Modal>
    );
}
```

**상수 추출 (필수):**

-   **사용자에게 보이는 모든 문구는 상수화**: 버튼/라벨/제목/힌트/설명/빈 상태 문구 등 **한 번만 써도** 상수로 정의합니다. 컴포넌트 안에 `"작업 기록이 없습니다"`, `"드래그하여 작업 추가"` 같은 하드코딩 문자열을 두지 않습니다.
-   **`message.info` / `message.success` / `message.error` / `message.warning`** 인자도 **반드시 상수**로 정의합니다. 예: `message.success("세션이 삭제되었습니다.")` → `message.success(GANTT_MESSAGE_SESSION_DELETED)`.

**스타일 작성: Tailwind 유틸리티 클래스 우선 (CRITICAL):**

> ⚠️ **절대 위반 금지**: 새 코드의 스타일은 **Tailwind 유틸리티 클래스**를 우선 사용합니다.
> `style={{...}}` inline 객체와 `CSSProperties` 상수는 **동적 계산 값**에만 허용합니다.

```typescript
// ❌ 금지: inline style 객체
<div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>...</div>

// ❌ 금지: CSSProperties 상수 (새 코드에서)
const HEADER_STYLE: React.CSSProperties = { display: "flex", gap: 8 };
<div style={HEADER_STYLE}>...</div>

// ✅ 필수: Tailwind 유틸리티 클래스
<div className="flex justify-between items-center">...</div>

// ✅ 허용: 동적 계산 값만 inline style 사용
<div
    className="absolute h-full rounded"
    style={{ left: `${start_pct}%`, width: `${width_pct}%` }}
>...</div>
```

**cn() 유틸리티 사용 (조건부 스타일):**

```typescript
import { cn } from "@/shared/lib/cn";

// ✅ 필수: 조건부 스타일은 cn() 사용
<div className={cn(
    "rounded-xl p-4 border",
    is_active
        ? "border-primary bg-white shadow-md"
        : "border-dashed border-border-default bg-bg-light"
)}>

// ✅ props로 className override 허용
interface CardProps {
    className?: string;
}
function Card({ className }: CardProps) {
    return <div className={cn("rounded-lg p-4 bg-white", className)}>...</div>;
}
```

**className 작성 순서:**

```typescript
className={cn(
    // 1. Layout (display, position, flex, grid)
    "flex items-center justify-between",
    // 2. Sizing (width, height)
    "w-full h-14",
    // 3. Spacing (margin, padding, gap)
    "px-6 py-4 gap-2",
    // 4. Typography (font, text)
    "text-sm font-medium text-text-primary",
    // 5. Visual (bg, border, shadow, rounded)
    "bg-white border border-border-default rounded-lg shadow-sm",
    // 6. Interactive (hover, focus, transition)
    "hover:bg-bg-light transition-colors duration-200",
    // 7. Responsive (sm:, md:, lg:, max-sm:)
    "max-sm:px-3 max-sm:h-[52px]",
    // 8. Conditional
    is_active && "border-primary bg-primary/5",
)}
```

**스타일 방식 결정 트리:**

```
New style needed?
├─ Simple layout/spacing/color/font? → Tailwind utility class
├─ Conditional/dynamic class?        → cn() + Tailwind classes
├─ Ant Design component override?    → CSS file with global selector (styles/overrides/)
├─ Complex pseudo-selector/nesting?  → CSS file (styles/components/)
├─ Dynamic value from JS?            → inline style={{ }} (ONLY exception)
├─ Entry/exit animation?             → framer-motion preset
└─ Repeating keyframe animation?     → CSS @keyframes (styles/utilities/keyframes.css)
```

**동적 CSS 주입 시 `@layer` 필수 (CRITICAL):**

> ⚠️ **절대 위반 금지**: JavaScript로 `<style>` 태그를 동적 주입할 때 반드시 `@layer`로 감싸야 합니다.

프로젝트는 Tailwind v4의 CSS Cascade Layers를 사용합니다:

```css
@layer base, antd, theme, components, utilities;
```

**CSS 사양상 unlayered CSS는 모든 layered CSS보다 항상 우선**합니다.
즉, `@layer` 없이 주입한 `<style>` 태그의 CSS는 Tailwind 유틸리티 클래스를 무조건 덮어씁니다.

```typescript
// ❌ 절대 금지: unlayered 동적 CSS 주입
const style = document.createElement("style");
style.textContent = `* { transition: scrollbar-color 0.3s ease-out; }`;
// → Tailwind의 transition-all, hover 효과 등을 모두 무력화

// ✅ 필수: @layer로 감싸서 Tailwind cascade와 공존
const style = document.createElement("style");
style.textContent = `
  @layer base {
    * { transition: scrollbar-color 0.3s ease-out; }
  }
`;
// → @layer base < @layer utilities 이므로 Tailwind이 정상 우선
```

**레이어 선택 기준:**

| CSS 유형              | 사용할 레이어       | 예시                      |
| --------------------- | ------------------- | ------------------------- |
| 리셋/전역 기본값      | `@layer base`       | scrollbar, font-smoothing |
| Ant Design 오버라이드 | `@layer antd`       | antd 컴포넌트 커스텀      |
| 컴포넌트 스타일       | `@layer components` | 기능별 CSS                |
| 유틸리티 확장         | `@layer utilities`  | 커스텀 유틸리티           |

**디자인 토큰 사용 (Tailwind theme tokens):**

```typescript
// ❌ 금지: 매직 넘버/색상 하드코딩
<div className="text-[#666] text-[12px] mt-[4px]">  // ← arbitrary values 남용 금지

// ✅ 필수: 디자인 토큰 참조
<div className="text-text-secondary text-sm mt-xs">

// 사용 가능한 토큰 (src/styles/tokens/ 참조):
// Colors: text-primary, text-text-secondary, bg-bg-light, border-border-default, ...
// Spacing: p-xs(4px), p-sm(8px), p-md(12px), p-lg(16px), p-xl(24px), ...
// Font: text-xs(10px), text-sm(12px), text-md(14px), text-lg(16px), ...
// Radius: rounded-xs(2px), rounded-sm(4px), rounded-md(6px), rounded-lg(8px), ...
// Z-Index: z-base, z-dropdown, z-modal, z-tooltip, z-top
```

**기존 CSSProperties 상수 (마이그레이션 중 허용):**

기존 `feature/constants/styles.ts`의 `CSSProperties` 상수는 마이그레이션 완료 전까지 **기존 코드에서 그대로 사용 가능**합니다.
새 코드에서는 Tailwind 클래스를 사용합니다.

**UI/메시지 문구 상수화 (기존 규칙 유지):**

```
❌ 금지: 인라인 UI/메시지 문구
message.success("세션이 삭제되었습니다.");
<Text>빈 영역을 드래그하여 작업 추가</Text>

✅ 필수: constants/labels 또는 feature constants 사용
message.success(GANTT_MESSAGE_SESSION_DELETED);
<Text>{GANTT_HINT_DRAG_TO_ADD}</Text>
```

**분리 기준:**

| 책임              | 위치                                   |
| ----------------- | -------------------------------------- |
| UI 렌더링         | `components/`, `ui/`                   |
| 비즈니스 로직     | `lib/` (순수 함수)                     |
| 상태 관리         | `store/`, `hooks/`                     |
| API 통신          | `api/`, `firebase/`                    |
| 타입 정의         | `types/`                               |
| 상수              | `config/`, `constants/`                |
| 디자인 토큰       | `styles/tokens/` (CSS vars)            |
| antd 오버라이드   | `styles/overrides/` (CSS)              |
| 피쳐 스타일       | `styles/components/` (CSS)             |
| 애니메이션        | `shared/ui/animation/` (framer-motion) |
| 유틸리티 (스타일) | `shared/lib/cn.ts` (className 합성)    |

---

### 3. 모바일/데스크탑 완전 분리 (Platform Independence)

모바일과 데스크탑은 **서로 영향을 주지 않습니다**.

```
❌ 금지: 조건문으로 플랫폼 분기 (if isMobile then ...)
✅ 필수: 플랫폼별 독립 컴포넌트 트리
```

**규칙:**

-   모바일 전용 컴포넌트: `Mobile*.tsx`
-   데스크탑 전용 컴포넌트: `Desktop*.tsx`
-   페이지 진입점에서 플랫폼별 컴포넌트 선택
-   **모바일 수정이 데스크탑에 영향을 주면 안 됨** (역도 마찬가지)
-   플랫폼 공통 로직은 `shared/` 또는 `hooks/`에서 공유

**구조 예시:**

```
pages/DailyPage/
├── index.tsx           # 플랫폼 스위칭
├── DesktopDailyPage.tsx
└── MobileDailyPage.tsx
```

**금지 패턴:**

```tsx
// ❌ 절대 금지
const Component = () => {
    const { is_mobile } = useResponsive();

    return is_mobile ? (
        <div className="mobile-layout">...</div>
    ) : (
        <div className="desktop-layout">...</div>
    );
};
```

**권장 패턴:**

```tsx
// ✅ 권장
// index.tsx
const DailyPage = () => {
    const { is_mobile } = useResponsive();
    return is_mobile ? <MobileDailyPage /> : <DesktopDailyPage />;
};

// DesktopDailyPage.tsx - 데스크탑만 신경
// MobileDailyPage.tsx - 모바일만 신경
```

---

### 4. 공통화 (DRY - Don't Repeat Yourself)

중복된 로직이나 UI는 **반드시 공통화**합니다.

```
❌ 금지: 같은 로직/UI가 여러 곳에 복사
✅ 필수: 한 곳에서 정의하고 재사용
```

**규칙:**

-   2회 이상 사용되는 로직 → `shared/lib/` 또는 `hooks/`로 추출
-   2회 이상 사용되는 UI → `shared/ui/` 또는 `components/`로 추출
-   공통 타입 → `shared/types/`에 정의
-   공통 상수 → `shared/config/`에 정의

**공통화 체크리스트:**

-   [ ] 이 로직이 다른 곳에도 있는가?
-   [ ] 이 UI 패턴이 다른 곳에도 있는가?
-   [ ] 추출해도 복잡도가 증가하지 않는가?

---

## 코드 품질 규칙 (Code Quality Rules)

### 순수 함수 우선 (Pure Functions First)

```
모든 계산 로직 → lib/ 폴더에 순수 함수로
부수 효과 → hooks/ 또는 store/에서만
```

**순수 함수 조건:**

-   동일 입력 → 동일 출력
-   외부 상태 변경 없음
-   외부 상태 읽기 없음 (매개변수로 전달)

---

### 명시적 의존성 (Explicit Dependencies)

```
❌ 금지: 암묵적 전역 상태 참조
✅ 필수: 모든 의존성을 매개변수로 전달
```

**예시:**

```typescript
// ❌ 금지: 내부에서 전역 상태 직접 참조
function calculateTotal() {
  const records = useWorkStore.getState().records;
  return records.reduce(...);
}

// ✅ 권장: 의존성을 매개변수로 전달
function calculateTotal(records: WorkRecord[]) {
  return records.reduce(...);
}
```

---

### 단방향 의존성 (Unidirectional Dependencies)

```
pages → widgets → features → shared
              ↓
   features 간 직접 import 금지
```

**규칙:**

-   상위 레이어는 하위 레이어만 import
-   같은 레이어 간 직접 import 금지 (shared를 통해서만)
-   순환 의존성 절대 금지

---

### 타입 안전성 (Type Safety)

```
❌ 금지: any, as 타입 단언, 타입 무시
✅ 필수: 엄격한 타입 정의
```

**규칙:**

-   `any` 사용 금지 (불가피한 경우 `unknown` 사용)
-   타입 단언(`as`) 최소화
-   모든 함수에 반환 타입 명시 권장
-   nullable 값은 명시적으로 처리

---

### 에러 처리 (Error Handling)

```
❌ 금지: 에러 무시, 빈 catch 블록
✅ 필수: 명시적 에러 처리
```

**규칙:**

-   try-catch 사용 시 에러 로깅 필수
-   사용자에게 의미 있는 에러 메시지 표시
-   에러 상태 UI 처리 (로딩/에러/성공)

---

### 상수 관리 (Constants Management)

```
❌ 금지: 하드코딩된 문자열, 매직 넘버, 중복 상수
✅ 필수: shared/constants/에서 중앙 집중 관리
```

**상수 위치:**

모든 상수는 `shared/constants/`에서 정의하고, 단일 진입점을 통해 접근합니다.

```
src/shared/constants/
├── index.ts          # Public API (단일 진입점)
├── app/              # 앱 설정 (storage_keys, admin, defaults)
├── enums/            # 타입 안전 enum (theme, status, shortcut, ui)
├── time/             # 시간 관련 (units, work_hours, durations)
├── style/            # 스타일 토큰 (colors, z_index, spacing)
└── ui/               # UI 텍스트 (buttons, messages, labels, modals)
```

**상수 정의 패턴:**

```typescript
// ✅ 권장: const 객체 + 타입 패턴 (enum 대체)
export const AppTheme = {
    Blue: "blue",
    Green: "green",
    Purple: "purple",
} as const;
export type AppTheme = (typeof AppTheme)[keyof typeof AppTheme];

// ✅ 권장: 시간 상수 명명
import { MINUTES_PER_HOUR, MS_PER_SECOND } from "@/shared/constants";
const total_ms = minutes * MINUTES_PER_HOUR * MS_PER_SECOND;

// ❌ 금지: 매직 넘버
const total_ms = minutes * 60 * 1000;
```

**상수 사용 규칙:**

| 상수 유형        | 위치               | 예시                                |
| ---------------- | ------------------ | ----------------------------------- |
| 앱 기본값        | `constants/app/`   | `DEFAULT_FORM_DATA`, `STORAGE_KEYS` |
| 타입 안전 enum   | `constants/enums/` | `AppTheme`, `SyncStatus`            |
| 시간/숫자 상수   | `constants/time/`  | `MINUTES_PER_HOUR`, `MS_PER_SECOND` |
| 색상/스타일 토큰 | `constants/style/` | `SEMANTIC_COLORS`, `Z_INDEX`        |
| UI 텍스트        | `constants/ui/`    | `BUTTON_TEXT`, `ERROR_MESSAGES`     |

**호환성 레이어:**

기존 import 경로(`store/constants`, `shared/config/`)는 새 구조에서 re-export합니다.

```typescript
// 기존 코드 호환 유지
import { DEFAULT_FORM_DATA } from "@/store/constants"; // 동작함

// 권장: 새 경로 사용
import { DEFAULT_FORM_DATA } from "@/shared/constants";
```

---

## 컴포넌트 설계 규칙 (Component Design Rules)

### Props 설계

```
❌ 금지: 10개 이상의 props, 중첩 객체 props
✅ 필수: 간결하고 명확한 props
```

**규칙:**

-   Props가 5개 초과 → 객체로 그룹화 검토
-   Props가 10개 초과 → 컴포넌트 분리 검토
-   콜백 함수는 `on` 접두사 (`onClick`, `onChange`)
-   boolean props는 긍정형 (`isVisible` vs `isHidden`)

---

### 상태 관리

```
❌ 금지: 컴포넌트 내 복잡한 상태 로직
✅ 필수: 상태 로직은 훅 또는 스토어로 분리
```

**상태 위치 결정:**

| 상태 범위          | 위치                        |
| ------------------ | --------------------------- |
| 단일 컴포넌트      | `useState`                  |
| 부모-자식 공유     | props drilling (2단계 이내) |
| 형제 컴포넌트 공유 | 부모로 상태 끌어올리기      |
| 전역 상태          | Zustand 스토어              |
| 서버 상태          | Firebase + 동기화 훅        |

---

### 렌더링 최적화

```
❌ 금지: 불필요한 리렌더링
✅ 필수: 메모이제이션 적절히 사용
```

**규칙:**

-   비용이 큰 계산 → `useMemo`
-   콜백 함수 → `useCallback` (자식에 전달 시)
-   순수 컴포넌트 → `React.memo` (필요시)
-   리스트 렌더링 → 안정적인 `key` 사용

---

## 파일/폴더 구조 규칙 (File Structure Rules)

### 네이밍 규칙

| 대상          | 규칙           | 예시                  |
| ------------- | -------------- | --------------------- |
| 컴포넌트 파일 | PascalCase     | `WorkRecordTable.tsx` |
| 훅 파일       | camelCase      | `useWorkStore.ts`     |
| 유틸 파일     | snake_case     | `time_utils.ts`       |
| 테스트 파일   | `*.test.ts(x)` | `time_utils.test.ts`  |
| 타입 파일     | snake_case     | `domain.ts`           |

### 코드 네이밍

| 대상            | 규칙             | 예시              |
| --------------- | ---------------- | ----------------- |
| 변수            | snake_case       | `selected_date`   |
| 함수            | camelCase        | `handleSubmit`    |
| 컴포넌트        | PascalCase       | `WorkRecordTable` |
| 상수            | UPPER_SNAKE_CASE | `DEFAULT_OPTIONS` |
| 타입/인터페이스 | PascalCase       | `WorkRecord`      |

---

### 폴더 구조

```
feature/
├── index.ts          # Public API (외부 노출)
├── model/            # 타입, 스토어 슬라이스
│   └── types.ts
├── lib/              # 순수 함수 (비즈니스 로직)
│   └── calculator.ts
├── ui/               # UI 컴포넌트
│   └── Component.tsx
└── hooks/            # 커스텀 훅
    └── useFeature.ts
```

---

## 테스트 전략 (Testing Strategy)

### 테스트 도구

| 도구                       | 용도                               |
| -------------------------- | ---------------------------------- |
| **Vitest**                 | 테스트 러너, 유닛 테스트           |
| **@testing-library/react** | 컴포넌트 렌더링 및 상호작용 테스트 |
| **fireEvent / userEvent**  | 사용자 이벤트 시뮬레이션           |

---

### 테스트 유형별 가이드

#### 1. 유닛 테스트 (Unit Test)

순수 함수는 **반드시 유닛 테스트**를 작성합니다.

```typescript
// lib/time/calculators.test.ts
describe("timeToMinutes", () => {
    it("09:30을 570분으로 변환한다", () => {
        expect(timeToMinutes("09:30")).toBe(570);
    });

    it("00:00을 0분으로 변환한다", () => {
        expect(timeToMinutes("00:00")).toBe(0);
    });
});
```

**위치:** `test/unit/` 폴더에 소스 구조 미러링

---

#### 2. 컴포넌트 테스트 (Component Test)

`@testing-library/react`를 사용하여 **렌더링 및 상호작용**을 테스트합니다.

```typescript
import { render, screen, fireEvent } from "@testing-library/react";

describe("SettingsModal", () => {
    it("모달이 열리면 제목이 표시된다", () => {
        render(<SettingsModal open={true} onClose={jest.fn()} />);
        expect(screen.getByText("설정")).toBeInTheDocument();
    });

    it("닫기 버튼 클릭 시 onClose가 호출된다", () => {
        const onClose = vi.fn();
        render(<SettingsModal open={true} onClose={onClose} />);

        fireEvent.click(screen.getByRole("button", { name: /닫기/ }));
        expect(onClose).toHaveBeenCalled();
    });
});
```

**위치:** `test/component/` 폴더

---

#### 3. 키보드 이벤트 테스트 (Keyboard Event Test)

단축키는 `fireEvent.keyDown`으로 검증합니다.

```typescript
describe("Keyboard Shortcuts", () => {
    it("F8 키를 누르면 타이머가 시작된다", () => {
        render(<App />);

        fireEvent.keyDown(document, { key: "F8", code: "F8" });

        expect(screen.getByTestId("timer")).toHaveTextContent(/\d{2}:\d{2}/);
    });

    it("Ctrl+S를 누르면 저장된다", () => {
        const onSave = vi.fn();
        render(<Editor onSave={onSave} />);

        fireEvent.keyDown(document, {
            key: "s",
            code: "KeyS",
            ctrlKey: true,
        });

        expect(onSave).toHaveBeenCalled();
    });
});
```

**주요 단축키 테스트 항목:**

-   F8: 타이머 시작/정지
-   Escape: 모달 닫기
-   Ctrl+S: 저장

---

#### 4. 모달 상태 테스트 (Modal State Test)

모달은 **열기/닫기/제출** 동작을 모두 검증합니다.

```typescript
describe("Modal State", () => {
    // 열기 테스트
    it("버튼 클릭 시 모달이 열린다", () => {
        render(<SettingsPage />);

        fireEvent.click(screen.getByText("설정"));

        expect(screen.getByRole("dialog")).toBeInTheDocument();
    });

    // 닫기 테스트 - 버튼
    it("닫기 버튼 클릭 시 모달이 닫힌다", () => {
        render(<SettingsModal open={true} onClose={onClose} />);

        fireEvent.click(screen.getByRole("button", { name: /닫기/ }));

        expect(onClose).toHaveBeenCalled();
    });

    // 닫기 테스트 - ESC 키
    it("ESC 키를 누르면 모달이 닫힌다", () => {
        render(<SettingsModal open={true} onClose={onClose} />);

        fireEvent.keyDown(document, { key: "Escape" });

        expect(onClose).toHaveBeenCalled();
    });

    // 제출 테스트
    it("폼 제출 시 onSubmit이 호출된다", () => {
        const onSubmit = vi.fn();
        render(<FormModal open={true} onSubmit={onSubmit} />);

        fireEvent.change(screen.getByLabelText("이름"), {
            target: { value: "테스트" },
        });
        fireEvent.click(screen.getByText("저장"));

        expect(onSubmit).toHaveBeenCalledWith({ name: "테스트" });
    });
});
```

---

#### 5. 스냅샷 테스트 (Snapshot Test)

UI 구조 변경을 감지합니다. **중요한 컴포넌트**에만 적용합니다.

```typescript
describe("Snapshot", () => {
    it("WorkRecordTable 구조가 유지된다", () => {
        const { container } = render(<WorkRecordTable records={mockRecords} />);

        expect(container).toMatchSnapshot();
    });
});
```

**스냅샷 테스트 대상:**

-   레이아웃 컴포넌트
-   복잡한 테이블/리스트 구조
-   디자인 시스템 컴포넌트

**주의사항:**

-   스냅샷이 자주 깨지면 **테스트 범위 축소** 검토
-   동적 데이터(날짜, ID)는 **mock**으로 고정
-   무의미한 스냅샷 업데이트 금지

---

### 테스트 작성 규칙

#### 필수 테스트 대상

| 대상               | 테스트 유형          | 필수 여부 |
| ------------------ | -------------------- | --------- |
| 순수 함수 (`lib/`) | 유닛 테스트          | ✅ 필수   |
| 커스텀 훅          | 훅 테스트            | ✅ 필수   |
| 폼 컴포넌트        | 상호작용 테스트      | ✅ 필수   |
| 모달               | 상태 테스트          | ✅ 필수   |
| 단축키             | 키보드 이벤트 테스트 | ✅ 필수   |
| 레이아웃           | 스냅샷 테스트        | 권장      |

#### 테스트 네이밍

```typescript
// ✅ 권장: 행동 기반 (한글 가능)
it("F8 키를 누르면 타이머가 시작된다", () => {});
it("빈 입력 시 에러 메시지가 표시된다", () => {});

// ❌ 금지: 구현 기반
it("handleClick이 호출된다", () => {});
it("state가 true가 된다", () => {});
```

#### AAA 패턴

모든 테스트는 **Arrange-Act-Assert** 패턴을 따릅니다.

```typescript
it("작업을 추가하면 목록에 표시된다", () => {
    // Arrange: 준비
    render(<WorkRecordTable records={[]} />);

    // Act: 실행
    fireEvent.click(screen.getByText("추가"));
    fireEvent.change(screen.getByLabelText("작업명"), {
        target: { value: "새 작업" },
    });
    fireEvent.click(screen.getByText("저장"));

    // Assert: 검증
    expect(screen.getByText("새 작업")).toBeInTheDocument();
});
```

---

### 테스트 폴더 구조

```
test/
├── unit/                         # 순수 함수 유닛 테스트
│   ├── shared/lib/               # 공유 라이브러리 테스트
│   │   ├── time/
│   │   └── lunch/
│   └── features/*/lib/           # 기능별 lib 테스트
│
├── component/                    # UI 컴포넌트 테스트
│   ├── features/                 # 기능별 컴포넌트 테스트
│   └── widgets/                  # 위젯 테스트
│
├── hooks/                        # 커스텀 훅 테스트
│
└── helpers/                      # 테스트 유틸리티
    └── mock_factory.ts           # 목 데이터 팩토리
```

---

### Mock 데이터 관리

`test/helpers/mock_factory.ts`에서 목 데이터를 생성합니다.

```typescript
// ✅ 권장: 팩토리 함수 사용
import { createMockRecord, createMockSession } from "@/test/helpers";

const record = createMockRecord({ work_name: "테스트 작업" });
const session = createMockSession({ start_time: "09:00" });

// ❌ 금지: 테스트 파일 내 하드코딩
const record = {
    id: "test-1",
    work_name: "테스트",
    // ... 20줄의 하드코딩된 데이터
};
```

---

### 테스트 실행 명령어

```bash
pnpm test              # watch 모드
pnpm test:run          # 단일 실행
pnpm test:run --coverage   # 커버리지 포함

# 특정 파일/폴더만 실행
pnpm test:run src/test/unit
pnpm test:run src/test/component/features/settings
```

---

## 금지 패턴 (Anti-Patterns)

### 절대 금지

1. **God Component**: 500줄 이상의 거대 컴포넌트
2. **Prop Drilling**: 3단계 이상의 props 전달
3. **Copy-Paste**: 같은 코드를 여러 곳에 복사
4. **Magic Number**: 의미 없는 숫자 리터럴
5. **Implicit State**: 암묵적 전역 상태 참조
6. **Platform Coupling**: 모바일/데스크탑 코드 결합
7. **Circular Dependency**: 순환 의존성
8. **Untestable Code**: 테스트 불가능한 구조

### 경고 (Warning)

1. `any` 타입 사용
2. 주석으로 코드 비활성화
3. TODO 주석 방치
4. 콘솔 로그 방치 (개발용 제외)
5. 하드코딩된 문자열 (상수화 필요)

---

## 코드 리뷰 체크리스트 (Review Checklist)

새 코드 작성 또는 수정 시 확인:

### 필수 체크

-   [ ] 테스트 가능한 구조인가?
-   [ ] 파일이 300줄을 초과하지 않는가?
-   [ ] 모바일/데스크탑이 분리되어 있는가?
-   [ ] 중복 코드가 없는가?
-   [ ] 순수 함수로 분리 가능한 로직이 있는가?
-   [ ] 타입이 명시적인가?
-   [ ] 린트 에러가 없는가?
-   [ ] 하드코딩된 문자열/숫자가 상수로 정의되어 있는가?

### 권장 체크

-   [ ] 네이밍이 명확한가?
-   [ ] 주석 없이도 코드가 이해되는가?
-   [ ] 에러 처리가 적절한가?
-   [ ] 성능 이슈가 없는가?

---

## 개발 프로세스 (Development Process)

### 새 기능 개발

1. **설계 검토**: 테스트 가능성, 분리 가능성 확인
2. **프로토타입**: 최소 기능 구현
3. **피드백**: 사용자 확인
4. **구현**: 전체 기능 개발
5. **테스트**: 유닛 테스트 작성
6. **리뷰**: 체크리스트 확인

### 버그 수정

1. **재현**: 버그 재현 확인
2. **테스트**: 실패하는 테스트 케이스 작성
3. **수정**: 버그 수정
4. **검증**: 테스트 통과 확인

### 리팩토링

1. **테스트 확보**: 기존 동작 테스트
2. **분리**: 관심사별 분리
3. **검증**: 테스트 통과 확인
4. **최적화**: 필요시 성능 개선

---

## 예외 처리 (Exceptions)

위 규칙의 예외가 필요한 경우:

1. **문서화**: 왜 예외가 필요한지 주석으로 설명
2. **최소화**: 예외 범위를 최소화
3. **TODO**: 향후 개선 계획 명시
4. **리뷰**: 예외 사유 공유

```typescript
// ⚠️ 예외: Ant Design 라이브러리 타입 호환성 문제로 any 사용
// TODO: 라이브러리 업데이트 후 타입 수정 필요
const handleChange = (value: any) => { ... };
```

---

## 참고 문서

-   `project-overview.mdc`: 프로젝트 구조 및 아키텍처
-   `versioning.mdc`: 버저닝 전략
-   `release-prep.mdc`: 릴리즈 프로세스
-   `docs/STYLE_ARCHITECTURE.md`: 스타일 아키텍처 설계 (Tailwind v4 + CSS Modules)
